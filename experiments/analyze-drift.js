#!/usr/bin/env node

/**
 * Drift Data Analysis Tool
 *
 * Analyzes CSV files generated by pi-drift-test.js and camera-drift-test.js
 * Generates detailed statistics and visualizations.
 *
 * Usage: node analyze-drift.js <csv-file> [--plot]
 * Example: node analyze-drift.js pi-drift-2024-01-15.csv --plot
 */

import fs from 'fs';
import path from 'path';

// Parse command line arguments
const args = process.argv.slice(2);
if (args.length === 0 || args.includes('--help')) {
  console.log(`
Usage: node analyze-drift.js <csv-file> [options]

Options:
  --plot              Generate ASCII plot of drift over time
  --compare <file>    Compare with another CSV file
  --export <file>     Export analysis to JSON file
  --help             Show this help message

Example:
  node analyze-drift.js pi-drift-2024-01-15.csv --plot
  node analyze-drift.js camera-drift.csv --compare pi-drift.csv
`);
  process.exit(0);
}

const CSV_FILE = args[0];
const SHOW_PLOT = args.includes('--plot');
const COMPARE_FILE = args.includes('--compare') ? args[args.indexOf('--compare') + 1] : null;
const EXPORT_FILE = args.includes('--export') ? args[args.indexOf('--export') + 1] : null;

// Read and parse CSV file
function readCSV(filename) {
  if (!fs.existsSync(filename)) {
    console.error(`File not found: ${filename}`);
    process.exit(1);
  }

  const content = fs.readFileSync(filename, 'utf-8');
  const lines = content.trim().split('\n');
  const headers = lines[0].split(',');

  const data = [];
  for (let i = 1; i < lines.length; i++) {
    const values = lines[i].split(',');
    const row = {};
    headers.forEach((header, index) => {
      const value = values[index];
      // Parse numbers
      if (header.includes('drift') || header.includes('check_number')) {
        row[header] = parseFloat(value) || 0;
      } else {
        row[header] = value;
      }
    });
    data.push(row);
  }

  return data;
}

// Calculate comprehensive statistics
function calculateStatistics(data) {
  if (data.length === 0) {
    return { error: 'No data points' };
  }

  const drifts = data.map(d => d.drift_seconds);
  const driftRates = data.map(d => d.drift_rate_seconds_per_hour);

  // Basic statistics
  const sum = arr => arr.reduce((a, b) => a + b, 0);
  const mean = arr => sum(arr) / arr.length;
  const median = arr => {
    const sorted = [...arr].sort((a, b) => a - b);
    const mid = Math.floor(sorted.length / 2);
    return sorted.length % 2 ? sorted[mid] : (sorted[mid - 1] + sorted[mid]) / 2;
  };
  const stdDev = arr => {
    const avg = mean(arr);
    const squareDiffs = arr.map(value => Math.pow(value - avg, 2));
    return Math.sqrt(mean(squareDiffs));
  };

  // Calculate percentiles
  const percentile = (arr, p) => {
    const sorted = [...arr].sort((a, b) => a - b);
    const index = (p / 100) * (sorted.length - 1);
    const lower = Math.floor(index);
    const upper = Math.ceil(index);
    const weight = index % 1;
    return sorted[lower] * (1 - weight) + sorted[upper] * weight;
  };

  // Time-based calculations
  const firstPoint = data[0];
  const lastPoint = data[data.length - 1];
  const totalHours = lastPoint.check_number * (lastPoint.check_number > 0 ?
    (new Date(lastPoint.timestamp) - new Date(firstPoint.timestamp)) / (lastPoint.check_number * 60 * 60 * 1000) : 0);

  // Trend analysis (linear regression)
  const xValues = data.map(d => d.check_number);
  const yValues = drifts;
  const n = xValues.length;
  const xMean = mean(xValues);
  const yMean = mean(yValues);

  let numerator = 0;
  let denominator = 0;
  for (let i = 0; i < n; i++) {
    numerator += (xValues[i] - xMean) * (yValues[i] - yMean);
    denominator += Math.pow(xValues[i] - xMean, 2);
  }
  const slope = denominator !== 0 ? numerator / denominator : 0;
  const intercept = yMean - slope * xMean;

  // Stability analysis
  const driftChanges = [];
  for (let i = 1; i < drifts.length; i++) {
    driftChanges.push(Math.abs(drifts[i] - drifts[i - 1]));
  }

  return {
    sampleCount: data.length,
    duration: {
      hours: totalHours,
      startTime: firstPoint.timestamp,
      endTime: lastPoint.timestamp
    },
    drift: {
      final: drifts[drifts.length - 1],
      mean: mean(drifts),
      median: median(drifts),
      stdDev: stdDev(drifts),
      min: Math.min(...drifts),
      max: Math.max(...drifts),
      p25: percentile(drifts, 25),
      p75: percentile(drifts, 75),
      p95: percentile(drifts, 95)
    },
    driftRate: {
      mean: mean(driftRates),
      median: median(driftRates),
      stdDev: stdDev(driftRates),
      min: Math.min(...driftRates),
      max: Math.max(...driftRates),
      final: driftRates[driftRates.length - 1]
    },
    trend: {
      slope: slope,  // drift change per measurement
      intercept: intercept,
      predictedDriftPerHour: slope * (60 / (totalHours / data.length)),  // Convert to per hour
      rSquared: calculateRSquared(xValues, yValues, slope, intercept)
    },
    stability: {
      meanChange: driftChanges.length > 0 ? mean(driftChanges) : 0,
      maxChange: driftChanges.length > 0 ? Math.max(...driftChanges) : 0,
      variability: stdDev(drifts) / Math.abs(mean(drifts)) * 100  // Coefficient of variation
    }
  };
}

// Calculate R-squared value
function calculateRSquared(x, y, slope, intercept) {
  const yMean = y.reduce((a, b) => a + b, 0) / y.length;
  let ssRes = 0;
  let ssTot = 0;

  for (let i = 0; i < x.length; i++) {
    const predicted = slope * x[i] + intercept;
    ssRes += Math.pow(y[i] - predicted, 2);
    ssTot += Math.pow(y[i] - yMean, 2);
  }

  return ssTot === 0 ? 0 : 1 - (ssRes / ssTot);
}

// Generate ASCII plot
function generatePlot(data, width = 70, height = 20) {
  if (data.length < 2) return 'Insufficient data for plot';

  const drifts = data.map(d => d.drift_seconds);
  const minDrift = Math.min(...drifts);
  const maxDrift = Math.max(...drifts);
  const range = maxDrift - minDrift || 1;

  // Create plot grid
  const plot = Array(height).fill(null).map(() => Array(width).fill(' '));

  // Plot data points
  data.forEach((point, index) => {
    const x = Math.floor((index / (data.length - 1)) * (width - 1));
    const y = Math.floor((1 - (point.drift_seconds - minDrift) / range) * (height - 1));
    if (x >= 0 && x < width && y >= 0 && y < height) {
      plot[y][x] = '●';
    }
  });

  // Add axes
  for (let y = 0; y < height; y++) {
    plot[y][0] = '│';
  }
  for (let x = 0; x < width; x++) {
    plot[height - 1][x] = '─';
  }
  plot[height - 1][0] = '└';

  // Convert to string
  const lines = [];
  lines.push(`Drift Over Time (${data.length} measurements)`);
  lines.push('═'.repeat(width));

  // Add y-axis labels
  for (let y = 0; y < height; y++) {
    const value = maxDrift - (y / (height - 1)) * range;
    const label = value.toFixed(1).padStart(6) + 's ';
    lines.push(label + plot[y].join(''));
  }

  // Add x-axis labels
  const startTime = new Date(data[0].timestamp);
  const endTime = new Date(data[data.length - 1].timestamp);
  const duration = (endTime - startTime) / (1000 * 60 * 60);
  lines.push('        ' + '0h' + ' '.repeat(width - 15) + duration.toFixed(1) + 'h');

  return lines.join('\n');
}

// Format statistics for display
function displayStatistics(stats, label = 'Statistics') {
  console.log('\n' + '='.repeat(60));
  console.log(label);
  console.log('='.repeat(60));

  console.log('\nDuration:');
  console.log(`  Total: ${stats.duration.hours.toFixed(1)} hours`);
  console.log(`  Start: ${stats.duration.startTime}`);
  console.log(`  End: ${stats.duration.endTime}`);
  console.log(`  Measurements: ${stats.sampleCount}`);

  console.log('\nDrift (seconds):');
  console.log(`  Final: ${stats.drift.final.toFixed(3)}`);
  console.log(`  Mean: ${stats.drift.mean.toFixed(3)}`);
  console.log(`  Median: ${stats.drift.median.toFixed(3)}`);
  console.log(`  Std Dev: ${stats.drift.stdDev.toFixed(3)}`);
  console.log(`  Range: ${stats.drift.min.toFixed(3)} to ${stats.drift.max.toFixed(3)}`);
  console.log(`  Quartiles: Q1=${stats.drift.p25.toFixed(3)}, Q3=${stats.drift.p75.toFixed(3)}`);
  console.log(`  95th percentile: ${stats.drift.p95.toFixed(3)}`);

  console.log('\nDrift Rate (seconds/hour):');
  console.log(`  Mean: ${stats.driftRate.mean.toFixed(4)}`);
  console.log(`  Median: ${stats.driftRate.median.toFixed(4)}`);
  console.log(`  Final: ${stats.driftRate.final.toFixed(4)}`);
  console.log(`  Range: ${stats.driftRate.min.toFixed(4)} to ${stats.driftRate.max.toFixed(4)}`);

  console.log('\nTrend Analysis:');
  console.log(`  Predicted drift rate: ${stats.trend.predictedDriftPerHour.toFixed(4)} seconds/hour`);
  console.log(`  R-squared: ${stats.trend.rSquared.toFixed(4)}`);
  console.log(`  Trend: ${stats.trend.slope > 0 ? 'Accelerating' : stats.trend.slope < 0 ? 'Decelerating' : 'Stable'}`);

  console.log('\nStability:');
  console.log(`  Mean change between measurements: ${stats.stability.meanChange.toFixed(4)} seconds`);
  console.log(`  Maximum change: ${stats.stability.maxChange.toFixed(4)} seconds`);
  console.log(`  Variability (CV): ${stats.stability.variability.toFixed(2)}%`);

  // Recommendations
  console.log('\n' + '-'.repeat(60));
  console.log('Recommendations:');
  const absRate = Math.abs(stats.driftRate.mean);
  if (absRate < 0.1) {
    console.log('  ✓ Very stable clock (drift < 0.1 s/hour)');
    console.log('  → Synchronization every 12-24 hours should be sufficient');
  } else if (absRate < 0.5) {
    console.log('  ✓ Stable clock (drift < 0.5 s/hour)');
    console.log('  → Synchronization every 4-6 hours recommended');
  } else if (absRate < 1.0) {
    console.log('  ⚠ Moderate drift (0.5-1.0 s/hour)');
    console.log('  → Synchronization every 2 hours recommended');
  } else {
    console.log('  ⚠ Significant drift (> 1.0 s/hour)');
    console.log('  → Hourly synchronization strongly recommended');
  }

  if (stats.stability.variability > 50) {
    console.log('  ⚠ High variability detected - clock may be unstable');
  }
}

// Compare two datasets
function compareDatasets(data1, data2, label1, label2) {
  const stats1 = calculateStatistics(data1);
  const stats2 = calculateStatistics(data2);

  console.log('\n' + '='.repeat(60));
  console.log('Comparison Analysis');
  console.log('='.repeat(60));

  console.log(`\n${label1} vs ${label2}`);
  console.log('-'.repeat(40));

  const metrics = [
    ['Final Drift (s)', stats1.drift.final, stats2.drift.final],
    ['Mean Drift Rate (s/h)', stats1.driftRate.mean, stats2.driftRate.mean],
    ['Drift Variability (%)', stats1.stability.variability, stats2.stability.variability],
    ['Max Drift (s)', stats1.drift.max, stats2.drift.max]
  ];

  metrics.forEach(([metric, val1, val2]) => {
    const diff = val2 - val1;
    const pctDiff = val1 !== 0 ? (diff / Math.abs(val1)) * 100 : 0;
    console.log(`${metric}:`);
    console.log(`  ${label1}: ${val1.toFixed(3)}`);
    console.log(`  ${label2}: ${val2.toFixed(3)}`);
    console.log(`  Difference: ${diff.toFixed(3)} (${pctDiff > 0 ? '+' : ''}${pctDiff.toFixed(1)}%)`);
  });

  // Determine which is more stable
  console.log('\n' + '-'.repeat(40));
  if (Math.abs(stats1.driftRate.mean) < Math.abs(stats2.driftRate.mean)) {
    console.log(`${label1} has a more stable clock`);
  } else {
    console.log(`${label2} has a more stable clock`);
  }
}

// Main analysis function
function main() {
  console.log(`\nAnalyzing drift data from: ${CSV_FILE}\n`);

  // Read primary dataset
  const data = readCSV(CSV_FILE);
  const stats = calculateStatistics(data);

  // Display statistics
  displayStatistics(stats, `Analysis of ${path.basename(CSV_FILE)}`);

  // Generate plot if requested
  if (SHOW_PLOT) {
    console.log('\n' + generatePlot(data));
  }

  // Compare with another file if provided
  if (COMPARE_FILE) {
    const compareData = readCSV(COMPARE_FILE);
    compareDatasets(
      data,
      compareData,
      path.basename(CSV_FILE),
      path.basename(COMPARE_FILE)
    );
  }

  // Export to JSON if requested
  if (EXPORT_FILE) {
    const exportData = {
      filename: CSV_FILE,
      analysisDate: new Date().toISOString(),
      statistics: stats,
      rawData: data
    };
    fs.writeFileSync(EXPORT_FILE, JSON.stringify(exportData, null, 2));
    console.log(`\nAnalysis exported to: ${EXPORT_FILE}`);
  }
}

// Run analysis
try {
  main();
} catch (error) {
  console.error('Analysis error:', error.message);
  process.exit(1);
}